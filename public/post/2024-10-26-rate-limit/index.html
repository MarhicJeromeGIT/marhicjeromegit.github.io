<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rate Limit | </title>
<meta name="keywords" content="">
<meta name="description" content="In this post, we&rsquo;ll discuss various common ways of handling API rate limits, and I&rsquo;ll introduce a new tool I&rsquo;ve been working on called MeterFlow.
Most APIs have rate limits, usually counted in requests per minute, but other resources can be limited as well (for instance, the number of characters you can translate with the Google Translate API, or the number of tokens you can generate with some LLM API). When you exceed the rate limit, the API will return a 429 status code, telling you to slow down. There are various ways of dealing with API rate limits in your code.">
<meta name="author" content="">
<link rel="canonical" href="/post/2024-10-26-rate-limit/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css" integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/post/2024-10-26-rate-limit/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="/post/2024-10-26-rate-limit/">
  <meta property="og:title" content="Rate Limit">
  <meta property="og:description" content="In this post, we’ll discuss various common ways of handling API rate limits, and I’ll introduce a new tool I’ve been working on called MeterFlow.
Most APIs have rate limits, usually counted in requests per minute, but other resources can be limited as well (for instance, the number of characters you can translate with the Google Translate API, or the number of tokens you can generate with some LLM API). When you exceed the rate limit, the API will return a 429 status code, telling you to slow down. There are various ways of dealing with API rate limits in your code.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-10-26T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-10-26T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rate Limit">
<meta name="twitter:description" content="In this post, we&rsquo;ll discuss various common ways of handling API rate limits, and I&rsquo;ll introduce a new tool I&rsquo;ve been working on called MeterFlow.
Most APIs have rate limits, usually counted in requests per minute, but other resources can be limited as well (for instance, the number of characters you can translate with the Google Translate API, or the number of tokens you can generate with some LLM API). When you exceed the rate limit, the API will return a 429 status code, telling you to slow down. There are various ways of dealing with API rate limits in your code.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Rate Limit",
      "item": "/post/2024-10-26-rate-limit/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rate Limit",
  "name": "Rate Limit",
  "description": "In this post, we\u0026rsquo;ll discuss various common ways of handling API rate limits, and I\u0026rsquo;ll introduce a new tool I\u0026rsquo;ve been working on called MeterFlow.\nMost APIs have rate limits, usually counted in requests per minute, but other resources can be limited as well (for instance, the number of characters you can translate with the Google Translate API, or the number of tokens you can generate with some LLM API). When you exceed the rate limit, the API will return a 429 status code, telling you to slow down. There are various ways of dealing with API rate limits in your code.\n",
  "keywords": [
    
  ],
  "articleBody": "In this post, we’ll discuss various common ways of handling API rate limits, and I’ll introduce a new tool I’ve been working on called MeterFlow.\nMost APIs have rate limits, usually counted in requests per minute, but other resources can be limited as well (for instance, the number of characters you can translate with the Google Translate API, or the number of tokens you can generate with some LLM API). When you exceed the rate limit, the API will return a 429 status code, telling you to slow down. There are various ways of dealing with API rate limits in your code.\n1. Ignore it Some API rate limits are pretty high, and you might not need to worry about them too much if you know your usage is low. For instance, the Google Translate API has a 6 million characters, 300,000 requests per minute quota. If it is unlikely you are ever going to translate this much (at $20 per million characters, you would be spending $120 per minute!), you may have ignored the rate limit so far with no consequence.\n2. Sleep on it An easy method is to retry the request a couple of times, with some sleep time in between. Simple Ruby pseudo-code:\nretry_count = 0 begin response = make_request() rescue Faraday::ClientError =\u003e e if e.response[:status] == 429 \u0026\u0026 retry_count \u003c MAX_RETRY_COUNT retry_count += 1 sleep 2 ** retry_count # exponential backoff retry else raise end end The request might succeed on the second or third try if the rate limit was reached temporarily due to a short burst of traffic. An alternative to sleeping is to raise an error and rely on Sidekiq’s retry mechanism to handle the retry.\nIn their cookbook, OpenAI suggests adding a delay proactively (sleeping before making the call), but it’s not ideal either (you are still paying for this CPU time!).\n3. Infrastructure rate limit If you are performing the API calls in the background (things like a Sidekiq job), you can limit the number of concurrent jobs (either with the number of processes/threads, or by making a capsule). For instance, if you are running 10 threads and each job takes at least 5 seconds to run, you know you won’t exceed 120 calls per minute to your external service.\n4. Introducing MeterFlow These solutions are not ideal: 1 and 2 can lead to failed requests, and 3 breaks anyway if you are calling the same API across multiple services (for instance, using an LLM endpoint to perform various tasks in separate microservices). Also, it is not easy to set a lower bound on your job execution time, so you’d have to account for some safety margin, leading to underutilization of your infrastructure. And anyway, you don’t want to run thousands of jobs and have them retry or sleep; ideally, you want to schedule them to run at the appropriate time.\nThis is where MeterFlow comes in. It is a simple, open-source service that can schedule your API calls, taking into account the current usage of the resource and the corresponding rate limits. The usage is simple: register a resource, then schedule calls to it. MeterFlow will return the delay before each call should be made.\n# Step 1: Request the schedule from MeterFlow uri = URI(\"http://localhost:8080/schedule\") response = Net::HTTP.post( uri, { resource_name: 'dummy_api', num_calls: 1000 }.to_json, \"Content-Type\" =\u003e \"application/json\" ) # Step 2: Parse the response and enqueue jobs based on the delay delays = JSON.parse(response.body)['delays'] delays.each_with_index do |delay, index| DummyApiCallWorker.perform_in(delay, index + 1) end If all the API calls to a given resource across your organization are scheduled by MeterFlow, you can be sure you won’t exceed the rate limit. Planned features include support for multiple limits per resource (for instance, calls per minute + characters per hour, etc.) and Prometheus data export for monitoring.\n",
  "wordCount" : "637",
  "inLanguage": "en",
  "datePublished": "2024-10-26T00:00:00Z",
  "dateModified": "2024-10-26T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/2024-10-26-rate-limit/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Rate Limit
    </h1>
    <div class="post-meta"><span title='2024-10-26 00:00:00 +0000 UTC'>October 26, 2024</span>

</div>
  </header> 
  <div class="post-content"><p>In this post, we&rsquo;ll discuss various common ways of handling API rate limits, and I&rsquo;ll introduce a new tool I&rsquo;ve been working on called <a href="https://github.com/goverture/meter_flow">MeterFlow</a>.</p>
<p>Most APIs have rate limits, usually counted in requests per minute, but other resources can be limited as well (for instance, the number of characters you can translate with the Google Translate API, or the number of tokens you can generate with some LLM API). When you exceed the rate limit, the API will return a 429 status code, telling you to slow down. There are various ways of dealing with API rate limits in your code.</p>
<h3 id="1-ignore-it">1. Ignore it<a hidden class="anchor" aria-hidden="true" href="#1-ignore-it">#</a></h3>
<p>Some API rate limits are pretty high, and you might not need to worry about them too much if you know your usage is low. For instance, the Google Translate API has a 6 million characters, 300,000 requests per minute <a href="https://cloud.google.com/translate/quotas">quota</a>. If it is unlikely you are ever going to translate this much (at $20 per million characters, you would be spending $120 per minute!), you may have ignored the rate limit so far with no consequence.</p>
<h3 id="2-sleep-on-it">2. Sleep on it<a hidden class="anchor" aria-hidden="true" href="#2-sleep-on-it">#</a></h3>
<p>An easy method is to retry the request a couple of times, with some sleep time in between. Simple Ruby pseudo-code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>retry_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>  response <span style="color:#f92672">=</span> make_request()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">rescue</span> <span style="color:#66d9ef">Faraday</span><span style="color:#f92672">::</span><span style="color:#66d9ef">ClientError</span> <span style="color:#f92672">=&gt;</span> e
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> e<span style="color:#f92672">.</span>response<span style="color:#f92672">[</span><span style="color:#e6db74">:status</span><span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">429</span> <span style="color:#f92672">&amp;&amp;</span> retry_count <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">MAX_RETRY_COUNT</span>
</span></span><span style="display:flex;"><span>    retry_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    sleep <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> retry_count <span style="color:#75715e"># exponential backoff</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">retry</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">raise</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>The request might succeed on the second or third try if the rate limit was reached temporarily due to a short burst of traffic. An alternative to sleeping is to raise an error and rely on Sidekiq&rsquo;s retry mechanism to handle the retry.</p>
<p>In their <a href="https://cookbook.openai.com/examples/how_to_handle_rate_limits#proactively-adding-delay-between-requests">cookbook</a>, OpenAI suggests adding a delay proactively (sleeping before making the call), but it&rsquo;s not ideal either (you are still paying for this CPU time!).</p>
<h3 id="3-infrastructure-rate-limit">3. Infrastructure rate limit<a hidden class="anchor" aria-hidden="true" href="#3-infrastructure-rate-limit">#</a></h3>
<p>If you are performing the API calls in the background (things like a Sidekiq job), you can limit the number of concurrent jobs (either with the number of processes/threads, or by making a <a href="https://github.com/sidekiq/sidekiq/blob/main/docs/capsule.md">capsule</a>). For instance, if you are running 10 threads and each job takes at least 5 seconds to run, you know you won&rsquo;t exceed 120 calls per minute to your external service.</p>
<h3 id="4-introducing-meterflow">4. Introducing MeterFlow<a hidden class="anchor" aria-hidden="true" href="#4-introducing-meterflow">#</a></h3>
<p>These solutions are not ideal: 1 and 2 can lead to failed requests, and 3 breaks anyway if you are calling the same API across multiple services (for instance, using an LLM endpoint to perform various tasks in separate microservices). Also, it is not easy to set a lower bound on your job execution time, so you&rsquo;d have to account for some safety margin, leading to underutilization of your infrastructure. And anyway, you don&rsquo;t want to run thousands of jobs and have them retry or sleep; ideally, you want to schedule them to run at the appropriate time.</p>
<p>This is where <a href="https://github.com/goverture/meter_flow">MeterFlow</a> comes in. It is a simple, open-source service that can schedule your API calls, taking into account the current usage of the resource and the corresponding rate limits. The usage is simple: register a resource, then schedule calls to it. MeterFlow will return the delay before each call should be made.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#75715e"># Step 1: Request the schedule from MeterFlow</span>
</span></span><span style="display:flex;"><span>uri <span style="color:#f92672">=</span> <span style="color:#66d9ef">URI</span>(<span style="color:#e6db74">&#34;http://localhost:8080/schedule&#34;</span>)
</span></span><span style="display:flex;"><span>response <span style="color:#f92672">=</span> <span style="color:#66d9ef">Net</span><span style="color:#f92672">::</span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">.</span>post(
</span></span><span style="display:flex;"><span>  uri,
</span></span><span style="display:flex;"><span>  { <span style="color:#e6db74">resource_name</span>: <span style="color:#e6db74">&#39;dummy_api&#39;</span>, <span style="color:#e6db74">num_calls</span>: <span style="color:#ae81ff">1000</span> }<span style="color:#f92672">.</span>to_json,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Content-Type&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;application/json&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Step 2: Parse the response and enqueue jobs based on the delay</span>
</span></span><span style="display:flex;"><span>delays <span style="color:#f92672">=</span> <span style="color:#66d9ef">JSON</span><span style="color:#f92672">.</span>parse(response<span style="color:#f92672">.</span>body)<span style="color:#f92672">[</span><span style="color:#e6db74">&#39;delays&#39;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>delays<span style="color:#f92672">.</span>each_with_index <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>delay, index<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">DummyApiCallWorker</span><span style="color:#f92672">.</span>perform_in(delay, index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>If all the API calls to a given resource across your organization are scheduled by MeterFlow, you can be sure you won&rsquo;t exceed the rate limit. Planned features include support for multiple limits per resource (for instance, calls per minute + characters per hour, etc.) and Prometheus data export for monitoring.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="/"></a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
