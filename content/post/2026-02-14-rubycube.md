---
title: "February 2026 - Rubycube"
date: 2026-02-14T09:41:14+09:00
draft: true
---

So I got this idea of making a Rubik's Cube solver in Ruby and I would call it RubyCube. Hilarious right ? But kind of stupid because nobody really care what the solver is written in as long as it actually work, right ? Looking back, I think similarly no user would care whether I vibe coded it with AI or I handcrafted each line, especially given that I'm not open sourcing it. Here for what matters, I vibe coded the front entirely (I just told Copilot to use [three.js](https://threejs.org/), don't ask me more) and manually coded the backend solver in Ruby.

It's live at [rubycube.jmarhic.com](https://rubycube.jmarhic.com) !

So, while I can't talk much about the frontend, the backend is quite elegant. I followed part of [Can a Rubik's Cube be brute-forced](https://www.stylewarning.com/posts/brute-force-rubiks-cube/) - in short I use a "brute-force + meet in the middle approach". To solve a given "state" we compute the follow up states by applying every possible rotation. We get a tree that we traverse in "breadth first order" (not depth first) to ensure we get the shortest solution. And to speed things up, I precomputed the 6 first levels (every possible states up to 6 rotations) and stored it in a db, so when solving a cube we only have to solve it "up to one of the stored state", not "up to the initial state". Anyway the code makes it much more comprehensible: notice the commented " if state == solved_state", replace by a db lookup "find_moves_for_state".

The cube state is represented as an array of number (each sticker from 0 to 23, it's a 2x2x2 cube by the way) and a move is just a permutation of this array. It was easy to write the permutation by hand, since I had a cube at hand and just wrote the number on each sticker. The most painful part of the code was converting from a "color state" (what the frontend sends, the color of each cubie for each face) to this "permutation state" (list of number).

```ruby
  def self.solve(state)
    queue = [[state, []]]

    while !queue.empty?
      state, moves = queue.shift
      #if state == solved_state
      pregenerated_moves = find_moves_for_state(state)
      if !pregenerated_moves.nil?
          # Return move names instead of permutations
          return moves + reverse_moves(pregenerated_moves.split(',').reverse)
      end

      next if moves.length > 6

      MOVES.each do |move_name, move|
        prev_move = moves.last
        # Avoid immediate inverse moves
        next if prev_move && inverse_move?(prev_move,move_name)

        queue << [rotate(state, move), moves + [move_name]]
      end
    end

    return [] # Couldn't find a solution, shouldn't happen
  end
```